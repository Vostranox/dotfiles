diff --git a/config.def.h b/config.def.h
index 1edb647..3841c08 100644
--- a/config.def.h
+++ b/config.def.h
@@ -1,23 +1,18 @@
-/* See LICENSE file for copyright and license details. */
-/* Default settings; can be overriden by command line. */
+static int topbar = 0;
+static int fuzzy  = 1;

-static int topbar = 1;                      /* -b  option; if 0, dmenu appears at bottom     */
-/* -fn option overrides fonts[0]; default X11 font or font set */
 static const char *fonts[] = {
-	"monospace:size=10"
+	"JetBrainsMono Nerd Font:size=8"
 };
-static const char *prompt      = NULL;      /* -p  option; prompt to the left of input field */
+
+static const char *prompt = NULL;
+
 static const char *colors[SchemeLast][2] = {
-	/*     fg         bg       */
-	[SchemeNorm] = { "#bbbbbb", "#222222" },
-	[SchemeSel] = { "#eeeeee", "#005577" },
-	[SchemeOut] = { "#000000", "#00ffff" },
+	[SchemeNorm] = { "#c8c8d5", "#181818" },
+	[SchemeSel]  = { "#95a99f", "#181818" },
+	[SchemeOut]  = { "#000000", "#96a6c8" },
 };
-/* -l option; if nonzero, dmenu uses vertical list with given number of lines */
-static unsigned int lines      = 0;

-/*
- * Characters not considered part of a word while deleting words
- * for example: " /?\"&[]"
- */
+static unsigned int lines = 0;
+
 static const char worddelimiters[] = " ";
diff --git a/config.mk b/config.mk
index dcc5bb3..27416f0 100644
--- a/config.mk
+++ b/config.mk
@@ -21,7 +21,7 @@ FREETYPEINC = /usr/include/freetype2

 # includes and libs
 INCS = -I$(X11INC) -I$(FREETYPEINC)
-LIBS = -L$(X11LIB) -lX11 $(XINERAMALIBS) $(FREETYPELIBS)
+LIBS = -L$(X11LIB) -lX11 $(XINERAMALIBS) $(FREETYPELIBS) -lm

 # flags
 CPPFLAGS = -D_DEFAULT_SOURCE -D_BSD_SOURCE -D_XOPEN_SOURCE=700 -D_POSIX_C_SOURCE=200809L -DVERSION=\"$(VERSION)\" $(XINERAMAFLAGS)
diff --git a/dmenu.1 b/dmenu.1
index 323f93c..e2c5ef4 100644
--- a/dmenu.1
+++ b/dmenu.1
@@ -3,7 +3,7 @@
 dmenu \- dynamic menu
 .SH SYNOPSIS
 .B dmenu
-.RB [ \-bfiv ]
+.RB [ \-bFfiv ]
 .RB [ \-l
 .IR lines ]
 .RB [ \-m
@@ -40,6 +40,9 @@ which lists programs in the user's $PATH and runs the result in their $SHELL.
 .B \-b
 dmenu appears at the bottom of the screen.
 .TP
+.B \-F
+disables fuzzy matching.
+.TP
 .B \-f
 dmenu grabs the keyboard before reading stdin if not reading from a tty. This
 is faster, but will lock up X until stdin reaches end\-of\-file.
diff --git a/dmenu.c b/dmenu.c
index 9577b37..6145b51 100644
--- a/dmenu.c
+++ b/dmenu.c
@@ -1,6 +1,7 @@
 /* See LICENSE file for copyright and license details. */
 #include <ctype.h>
 #include <locale.h>
+#include <math.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -28,9 +29,11 @@
 enum { SchemeNorm, SchemeSel, SchemeOut, SchemeLast }; /* color schemes */

 struct item {
-	char *text;
-	struct item *left, *right;
-	int out;
+    char *text;
+    struct item *left, *right;
+    int out;
+    double distance;
+    int index; /* original read order (for stable tie-breaking) */
 };

 static char text[BUFSIZ] = "";
@@ -54,742 +57,910 @@ static Clr *scheme[SchemeLast];

 #include "config.h"

-static int (*fstrncmp)(const char *, const char *, size_t) = strncmp;
-static char *(*fstrstr)(const char *, const char *) = strstr;
+static char * cistrstr(const char *s, const char *sub);
+static int (*fstrncmp)(const char *, const char *, size_t) = strncasecmp;
+static char *(*fstrstr)(const char *, const char *) = cistrstr;
+
+/* forward decls for fuzzy helpers */
+static int subseq_min_window_ci(const char *hay, const char *needle, int *sidx, int *eidx);
+static int compare_distance_then_text(const void *a, const void *b);

 static unsigned int
 textw_clamp(const char *str, unsigned int n)
 {
-	unsigned int w = drw_fontset_getwidth_clamp(drw, str, n) + lrpad;
-	return MIN(w, n);
+    unsigned int w = drw_fontset_getwidth_clamp(drw, str, n) + lrpad;
+    return MIN(w, n);
 }

 static void
 appenditem(struct item *item, struct item **list, struct item **last)
 {
-	if (*last)
-		(*last)->right = item;
-	else
-		*list = item;
-
-	item->left = *last;
-	item->right = NULL;
-	*last = item;
+    if (*last)
+        (*last)->right = item;
+    else
+        *list = item;
+
+    item->left = *last;
+    item->right = NULL;
+    *last = item;
 }

 static void
 calcoffsets(void)
 {
-	int i, n;
-
-	if (lines > 0)
-		n = lines * bh;
-	else
-		n = mw - (promptw + inputw + TEXTW("<") + TEXTW(">"));
-	/* calculate which items will begin the next page and previous page */
-	for (i = 0, next = curr; next; next = next->right)
-		if ((i += (lines > 0) ? bh : textw_clamp(next->text, n)) > n)
-			break;
-	for (i = 0, prev = curr; prev && prev->left; prev = prev->left)
-		if ((i += (lines > 0) ? bh : textw_clamp(prev->left->text, n)) > n)
-			break;
+    int i, n;
+
+    if (lines > 0)
+        n = lines * bh;
+    else
+        n = mw - (promptw + inputw + TEXTW("<") + TEXTW(">"));
+    /* calculate which items will begin the next page and previous page */
+    for (i = 0, next = curr; next; next = next->right)
+        if ((i += (lines > 0) ? bh : textw_clamp(next->text, n)) > n)
+            break;
+    for (i = 0, prev = curr; prev && prev->left; prev = prev->left)
+        if ((i += (lines > 0) ? bh : textw_clamp(prev->left->text, n)) > n)
+            break;
 }

 static void
 cleanup(void)
 {
-	size_t i;
-
-	XUngrabKeyboard(dpy, CurrentTime);
-	for (i = 0; i < SchemeLast; i++)
-		drw_scm_free(drw, scheme[i], 2);
-	for (i = 0; items && items[i].text; ++i)
-		free(items[i].text);
-	free(items);
-	drw_free(drw);
-	XSync(dpy, False);
-	XCloseDisplay(dpy);
+    size_t i;
+
+    XUngrabKeyboard(dpy, CurrentTime);
+    for (i = 0; i < SchemeLast; i++)
+        drw_scm_free(drw, scheme[i], 2);
+    for (i = 0; items && items[i].text; ++i)
+        free(items[i].text);
+    free(items);
+    drw_free(drw);
+    XSync(dpy, False);
+    XCloseDisplay(dpy);
 }

 static char *
 cistrstr(const char *h, const char *n)
 {
-	size_t i;
-
-	if (!n[0])
-		return (char *)h;
-
-	for (; *h; ++h) {
-		for (i = 0; n[i] && tolower((unsigned char)n[i]) ==
-		            tolower((unsigned char)h[i]); ++i)
-			;
-		if (n[i] == '\0')
-			return (char *)h;
-	}
-	return NULL;
+    size_t i;
+
+    if (!n[0])
+        return (char *)h;
+
+    for (; *h; ++h) {
+        for (i = 0; n[i] && tolower((unsigned char)n[i]) ==
+                    tolower((unsigned char)h[i]); ++i)
+            ;
+        if (n[i] == '\0')
+            return (char *)h;
+    }
+    return NULL;
 }

 static int
 drawitem(struct item *item, int x, int y, int w)
 {
-	if (item == sel)
-		drw_setscheme(drw, scheme[SchemeSel]);
-	else if (item->out)
-		drw_setscheme(drw, scheme[SchemeOut]);
-	else
-		drw_setscheme(drw, scheme[SchemeNorm]);
-
-	return drw_text(drw, x, y, w, bh, lrpad / 2, item->text, 0);
+    if (item == sel)
+        drw_setscheme(drw, scheme[SchemeSel]);
+    else if (item->out)
+        drw_setscheme(drw, scheme[SchemeOut]);
+    else
+        drw_setscheme(drw, scheme[SchemeNorm]);
+
+    return drw_text(drw, x, y, w, bh, lrpad / 2, item->text, 0);
 }

 static void
 drawmenu(void)
 {
-	unsigned int curpos;
-	struct item *item;
-	int x = 0, y = 0, w;
-
-	drw_setscheme(drw, scheme[SchemeNorm]);
-	drw_rect(drw, 0, 0, mw, mh, 1, 1);
-
-	if (prompt && *prompt) {
-		drw_setscheme(drw, scheme[SchemeSel]);
-		x = drw_text(drw, x, 0, promptw, bh, lrpad / 2, prompt, 0);
-	}
-	/* draw input field */
-	w = (lines > 0 || !matches) ? mw - x : inputw;
-	drw_setscheme(drw, scheme[SchemeNorm]);
-	drw_text(drw, x, 0, w, bh, lrpad / 2, text, 0);
-
-	curpos = TEXTW(text) - TEXTW(&text[cursor]);
-	if ((curpos += lrpad / 2 - 1) < w) {
-		drw_setscheme(drw, scheme[SchemeNorm]);
-		drw_rect(drw, x + curpos, 2, 2, bh - 4, 1, 0);
-	}
-
-	if (lines > 0) {
-		/* draw vertical list */
-		for (item = curr; item != next; item = item->right)
-			drawitem(item, x, y += bh, mw - x);
-	} else if (matches) {
-		/* draw horizontal list */
-		x += inputw;
-		w = TEXTW("<");
-		if (curr->left) {
-			drw_setscheme(drw, scheme[SchemeNorm]);
-			drw_text(drw, x, 0, w, bh, lrpad / 2, "<", 0);
-		}
-		x += w;
-		for (item = curr; item != next; item = item->right)
-			x = drawitem(item, x, 0, textw_clamp(item->text, mw - x - TEXTW(">")));
-		if (next) {
-			w = TEXTW(">");
-			drw_setscheme(drw, scheme[SchemeNorm]);
-			drw_text(drw, mw - w, 0, w, bh, lrpad / 2, ">", 0);
-		}
-	}
-	drw_map(drw, win, 0, 0, mw, mh);
+    unsigned int curpos;
+    struct item *item;
+    int x = 0, y = 0, w;
+
+    drw_setscheme(drw, scheme[SchemeNorm]);
+    drw_rect(drw, 0, 0, mw, mh, 1, 1);
+
+    if (prompt && *prompt) {
+        drw_setscheme(drw, scheme[SchemeSel]);
+        x = drw_text(drw, x, 0, promptw, bh, lrpad / 2, prompt, 0);
+    }
+    /* draw input field */
+    w = (lines > 0 || !matches) ? mw - x : inputw;
+    drw_setscheme(drw, scheme[SchemeNorm]);
+    drw_text(drw, x, 0, w, bh, lrpad / 2, text, 0);
+
+    curpos = TEXTW(text) - TEXTW(&text[cursor]);
+    if ((curpos += lrpad / 2 - 1) < w) {
+        drw_setscheme(drw, scheme[SchemeNorm]);
+        drw_rect(drw, x + curpos, 2, 2, bh - 4, 1, 0);
+    }
+
+    if (lines > 0) {
+        /* draw vertical list */
+        for (item = curr; item != next; item = item->right)
+            drawitem(item, x, y += bh, mw - x);
+    } else if (matches) {
+        /* draw horizontal list */
+        x += inputw;
+        w = TEXTW("<");
+        if (curr->left) {
+            drw_setscheme(drw, scheme[SchemeNorm]);
+            drw_text(drw, x, 0, w, bh, lrpad / 2, "<", 0);
+        }
+        x += w;
+        for (item = curr; item != next; item = item->right)
+            x = drawitem(item, x, 0, textw_clamp(item->text, mw - x - TEXTW(">")));
+        if (next) {
+            w = TEXTW(">");
+            drw_setscheme(drw, scheme[SchemeNorm]);
+            drw_text(drw, mw - w, 0, w, bh, lrpad / 2, ">", 0);
+        }
+    }
+    drw_map(drw, win, 0, 0, mw, mh);
 }

 static void
 grabfocus(void)
 {
-	struct timespec ts = { .tv_sec = 0, .tv_nsec = 10000000  };
-	Window focuswin;
-	int i, revertwin;
-
-	for (i = 0; i < 100; ++i) {
-		XGetInputFocus(dpy, &focuswin, &revertwin);
-		if (focuswin == win)
-			return;
-		XSetInputFocus(dpy, win, RevertToParent, CurrentTime);
-		nanosleep(&ts, NULL);
-	}
-	die("cannot grab focus");
+    struct timespec ts = { .tv_sec = 0, .tv_nsec = 10000000  };
+    Window focuswin;
+    int i, revertwin;
+
+    for (i = 0; i < 100; ++i) {
+        XGetInputFocus(dpy, &focuswin, &revertwin);
+        if (focuswin == win)
+            return;
+        XSetInputFocus(dpy, win, RevertToParent, CurrentTime);
+        nanosleep(&ts, NULL);
+    }
+    die("cannot grab focus");
 }

 static void
 grabkeyboard(void)
 {
-	struct timespec ts = { .tv_sec = 0, .tv_nsec = 1000000  };
-	int i;
-
-	if (embed)
-		return;
-	/* try to grab keyboard, we may have to wait for another process to ungrab */
-	for (i = 0; i < 1000; i++) {
-		if (XGrabKeyboard(dpy, DefaultRootWindow(dpy), True, GrabModeAsync,
-		                  GrabModeAsync, CurrentTime) == GrabSuccess)
-			return;
-		nanosleep(&ts, NULL);
-	}
-	die("cannot grab keyboard");
+    struct timespec ts = { .tv_sec = 0, .tv_nsec = 1000000  };
+    int i;
+
+    if (embed)
+        return;
+    /* try to grab keyboard, we may have to wait for another process to ungrab */
+    for (i = 0; i < 1000; i++) {
+        if (XGrabKeyboard(dpy, DefaultRootWindow(dpy), True, GrabModeAsync,
+                          GrabModeAsync, CurrentTime) == GrabSuccess)
+            return;
+        nanosleep(&ts, NULL);
+    }
+    die("cannot grab keyboard");
+}
+
+/* Compare by distance, then text (ci), then original index for stability */
+static int
+compare_distance_then_text(const void *a, const void *b)
+{
+    const struct item *da = *(const struct item * const *) a;
+    const struct item *db = *(const struct item * const *) b;
+
+    if (!db) return 1;
+    if (!da) return -1;
+
+    if (da->distance < db->distance) return -1;
+    if (da->distance > db->distance) return 1;
+
+    int t = strcasecmp(da->text, db->text);
+    if (t) return t;
+
+    /* final stable tiebreaker: original input order */
+    return (da->index < db->index) ? -1 : (da->index > db->index);
+}
+
+/* minimal-window subsequence match (case-insensitive).
+ * Writes the tightest [sidx,eidx] span that contains `needle` as a subsequence of `hay`.
+ * Returns 1 if matched, 0 otherwise.
+ */
+static int
+subseq_min_window_ci(const char *hay, const char *needle, int *sidx, int *eidx)
+{
+    int best_s = -1, best_e = -1;
+    size_t hlen = strlen(hay);
+    size_t nlen = strlen(needle);
+
+    if (nlen == 0) {
+        if (sidx) *sidx = 0;
+        if (eidx) *eidx = -1;
+        return 1;
+    }
+
+    for (size_t i = 0; i < hlen; ) {
+        /* forward: find end that completes subsequence */
+        size_t hi = i, nj = 0;
+        while (hi < hlen && nj < nlen) {
+            if (tolower((unsigned char)hay[hi]) == tolower((unsigned char)needle[nj]))
+                nj++;
+            hi++;
+        }
+        if (nj < nlen) break; /* no more completions */
+
+        /* backward: shrink to earliest start */
+        size_t end = hi - 1;
+        nj = nlen;
+        size_t hj = end + 1;
+        while (hj > i && nj > 0) {
+            hj--;
+            if (tolower((unsigned char)hay[hj]) == tolower((unsigned char)needle[nj - 1]))
+                nj--;
+        }
+        if (nj == 0) {
+            int start = (int)hj;
+            int e = (int)end;
+            if (best_s < 0 || (e - start) < (best_e - best_s)) {
+                best_s = start; best_e = e;
+            }
+            /* advance to look for potentially tighter windows */
+            i = (size_t)start + 1;
+        } else {
+            i = hi;
+        }
+    }
+
+    if (best_s >= 0) {
+        if (sidx) *sidx = best_s;
+        if (eidx) *eidx = best_e;
+        return 1;
+    }
+    return 0;
+}
+
+static void
+fuzzymatch(void)
+{
+    struct item *it;
+    struct item **fuzzymatches = NULL;
+    int number_of_matches = 0, i;
+
+    /* tokenize query by spaces (orderless components) */
+    char buf[sizeof text], *tok, **tokv = NULL;
+    int tokn = 0, tokc = 0;
+
+    matches = matchend = NULL;
+
+    /* Build token array tokv[0..tokc-1] */
+    strcpy(buf, text);
+    for (tok = strtok(buf, " "); tok; tok = strtok(NULL, " ")) {
+        if (tokc + 1 > tokn) {
+            tokn = (tokn ? tokn * 2 : 4);
+            tokv = realloc(tokv, tokn * sizeof *tokv);
+            if (!tokv) die("cannot realloc %zu bytes:", tokn * sizeof *tokv);
+        }
+        tokv[tokc++] = tok;
+    }
+
+    for (it = items; it && it->text; ++it) {
+        if (tokc == 0) {
+            /* empty query -> include all */
+            it->distance = 0.0;
+            appenditem(it, &matches, &matchend);
+            ++number_of_matches;
+            continue;
+        }
+
+        /* For each token, require subsequence match; sum distances using minimal windows */
+        double total = 0.0;
+        int all_ok = 1;
+        for (i = 0; i < tokc; ++i) {
+            int sidx = -1, eidx = -1;
+            if (!subseq_min_window_ci(it->text, tokv[i], &sidx, &eidx)) {
+                all_ok = 0;
+                break;
+            }
+            int tlen = (int)strlen(tokv[i]);
+            int gap = eidx - sidx - tlen; /* can be -1 when contiguous; that's okay */
+            total += log(sidx + 2.0) + (double)gap;
+        }
+
+        if (all_ok) {
+            it->distance = total;
+            appenditem(it, &matches, &matchend);
+            ++number_of_matches;
+        }
+    }
+
+    if (number_of_matches) {
+        /* initialize array with matches */
+        fuzzymatches = realloc(fuzzymatches, number_of_matches * sizeof *fuzzymatches);
+        if (!fuzzymatches) die("cannot realloc %u bytes:", number_of_matches * (unsigned)sizeof *fuzzymatches);
+        struct item *p;
+        for (i = 0, p = matches; p && i < number_of_matches; ++i, p = p->right)
+            fuzzymatches[i] = p;
+
+        /* sort matches by distance, then text, then original index (stable feel) */
+        qsort(fuzzymatches, number_of_matches, sizeof *fuzzymatches, compare_distance_then_text);
+
+        /* rebuild list */
+        matches = matchend = NULL;
+        for (i = 0; i < number_of_matches; ++i)
+            appenditem(fuzzymatches[i], &matches, &matchend);
+
+        free(fuzzymatches);
+    }
+
+    free(tokv);
+    curr = sel = matches;
+    calcoffsets();
 }

 static void
 match(void)
 {
-	static char **tokv = NULL;
-	static int tokn = 0;
-
-	char buf[sizeof text], *s;
-	int i, tokc = 0;
-	size_t len, textsize;
-	struct item *item, *lprefix, *lsubstr, *prefixend, *substrend;
-
-	strcpy(buf, text);
-	/* separate input text into tokens to be matched individually */
-	for (s = strtok(buf, " "); s; tokv[tokc - 1] = s, s = strtok(NULL, " "))
-		if (++tokc > tokn && !(tokv = realloc(tokv, ++tokn * sizeof *tokv)))
-			die("cannot realloc %zu bytes:", tokn * sizeof *tokv);
-	len = tokc ? strlen(tokv[0]) : 0;
-
-	matches = lprefix = lsubstr = matchend = prefixend = substrend = NULL;
-	textsize = strlen(text) + 1;
-	for (item = items; item && item->text; item++) {
-		for (i = 0; i < tokc; i++)
-			if (!fstrstr(item->text, tokv[i]))
-				break;
-		if (i != tokc) /* not all tokens match */
-			continue;
-		/* exact matches go first, then prefixes, then substrings */
-		if (!tokc || !fstrncmp(text, item->text, textsize))
-			appenditem(item, &matches, &matchend);
-		else if (!fstrncmp(tokv[0], item->text, len))
-			appenditem(item, &lprefix, &prefixend);
-		else
-			appenditem(item, &lsubstr, &substrend);
-	}
-	if (lprefix) {
-		if (matches) {
-			matchend->right = lprefix;
-			lprefix->left = matchend;
-		} else
-			matches = lprefix;
-		matchend = prefixend;
-	}
-	if (lsubstr) {
-		if (matches) {
-			matchend->right = lsubstr;
-			lsubstr->left = matchend;
-		} else
-			matches = lsubstr;
-		matchend = substrend;
-	}
-	curr = sel = matches;
-	calcoffsets();
+    if (fuzzy) {
+        fuzzymatch();
+        return;
+    }
+    static char **tokv = NULL;
+    static int tokn = 0;
+
+    char buf[sizeof text], *s;
+    int i, tokc = 0;
+    size_t len, textsize;
+    struct item *item, *lprefix, *lsubstr, *prefixend, *substrend;
+
+    strcpy(buf, text);
+    /* separate input text into tokens to be matched individually */
+    for (s = strtok(buf, " "); s; tokv[tokc - 1] = s, s = strtok(NULL, " "))
+        if (++tokc > tokn && !(tokv = realloc(tokv, ++tokn * sizeof *tokv)))
+            die("cannot realloc %zu bytes:", tokn * sizeof *tokv);
+    len = tokc ? strlen(tokv[0]) : 0;
+
+    matches = lprefix = lsubstr = matchend = prefixend = substrend = NULL;
+    textsize = strlen(text) + 1;
+    for (item = items; item && item->text; item++) {
+        for (i = 0; i < tokc; i++)
+            if (!fstrstr(item->text, tokv[i]))
+                break;
+        if (i != tokc) /* not all tokens match */
+            continue;
+        /* exact matches go first, then prefixes, then substrings */
+        if (!tokc || !fstrncmp(text, item->text, textsize))
+            appenditem(item, &matches, &matchend);
+        else if (!fstrncmp(tokv[0], item->text, len))
+            appenditem(item, &lprefix, &prefixend);
+        else
+            appenditem(item, &lsubstr, &substrend);
+    }
+    if (lprefix) {
+        if (matches) {
+            matchend->right = lprefix;
+            lprefix->left = matchend;
+        } else
+            matches = lprefix;
+        matchend = prefixend;
+    }
+    if (lsubstr) {
+        if (matches) {
+            matchend->right = lsubstr;
+            lsubstr->left = matchend;
+        } else
+            matches = lsubstr;
+        matchend = substrend;
+    }
+    curr = sel = matches;
+    calcoffsets();
 }

 static void
 insert(const char *str, ssize_t n)
 {
-	if (strlen(text) + n > sizeof text - 1)
-		return;
-	/* move existing text out of the way, insert new text, and update cursor */
-	memmove(&text[cursor + n], &text[cursor], sizeof text - cursor - MAX(n, 0));
-	if (n > 0)
-		memcpy(&text[cursor], str, n);
-	cursor += n;
-	match();
+    if (strlen(text) + n > sizeof text - 1)
+        return;
+    /* move existing text out of the way, insert new text, and update cursor */
+    memmove(&text[cursor + n], &text[cursor], sizeof text - cursor - MAX(n, 0));
+    if (n > 0)
+        memcpy(&text[cursor], str, n);
+    cursor += n;
+    match();
 }

 static size_t
 nextrune(int inc)
 {
-	ssize_t n;
+    ssize_t n;

-	/* return location of next utf8 rune in the given direction (+1 or -1) */
-	for (n = cursor + inc; n + inc >= 0 && (text[n] & 0xc0) == 0x80; n += inc)
-		;
-	return n;
+    /* return location of next utf8 rune in the given direction (+1 or -1) */
+    for (n = cursor + inc; n + inc >= 0 && (text[n] & 0xc0) == 0x80; n += inc)
+        ;
+    return n;
 }

 static void
 movewordedge(int dir)
 {
-	if (dir < 0) { /* move cursor to the start of the word*/
-		while (cursor > 0 && strchr(worddelimiters, text[nextrune(-1)]))
-			cursor = nextrune(-1);
-		while (cursor > 0 && !strchr(worddelimiters, text[nextrune(-1)]))
-			cursor = nextrune(-1);
-	} else { /* move cursor to the end of the word */
-		while (text[cursor] && strchr(worddelimiters, text[cursor]))
-			cursor = nextrune(+1);
-		while (text[cursor] && !strchr(worddelimiters, text[cursor]))
-			cursor = nextrune(+1);
-	}
+    if (dir < 0) { /* move cursor to the start of the word*/
+        while (cursor > 0 && strchr(worddelimiters, text[nextrune(-1)]))
+            cursor = nextrune(-1);
+        while (cursor > 0 && !strchr(worddelimiters, text[nextrune(-1)]))
+            cursor = nextrune(-1);
+    } else { /* move cursor to the end of the word */
+        while (text[cursor] && strchr(worddelimiters, text[cursor]))
+            cursor = nextrune(+1);
+        while (text[cursor] && !strchr(worddelimiters, text[cursor]))
+            cursor = nextrune(+1);
+    }
 }

 static void
 keypress(XKeyEvent *ev)
 {
-	char buf[64];
-	int len;
-	KeySym ksym = NoSymbol;
-	Status status;
-
-	len = XmbLookupString(xic, ev, buf, sizeof buf, &ksym, &status);
-	switch (status) {
-	default: /* XLookupNone, XBufferOverflow */
-		return;
-	case XLookupChars: /* composed string from input method */
-		goto insert;
-	case XLookupKeySym:
-	case XLookupBoth: /* a KeySym and a string are returned: use keysym */
-		break;
-	}
-
-	if (ev->state & ControlMask) {
-		switch(ksym) {
-		case XK_a: ksym = XK_Home;      break;
-		case XK_b: ksym = XK_Left;      break;
-		case XK_c: ksym = XK_Escape;    break;
-		case XK_d: ksym = XK_Delete;    break;
-		case XK_e: ksym = XK_End;       break;
-		case XK_f: ksym = XK_Right;     break;
-		case XK_g: ksym = XK_Escape;    break;
-		case XK_h: ksym = XK_BackSpace; break;
-		case XK_i: ksym = XK_Tab;       break;
-		case XK_j: /* fallthrough */
-		case XK_J: /* fallthrough */
-		case XK_m: /* fallthrough */
-		case XK_M: ksym = XK_Return; ev->state &= ~ControlMask; break;
-		case XK_n: ksym = XK_Down;      break;
-		case XK_p: ksym = XK_Up;        break;
-
-		case XK_k: /* delete right */
-			text[cursor] = '\0';
-			match();
-			break;
-		case XK_u: /* delete left */
-			insert(NULL, 0 - cursor);
-			break;
-		case XK_w: /* delete word */
-			while (cursor > 0 && strchr(worddelimiters, text[nextrune(-1)]))
-				insert(NULL, nextrune(-1) - cursor);
-			while (cursor > 0 && !strchr(worddelimiters, text[nextrune(-1)]))
-				insert(NULL, nextrune(-1) - cursor);
-			break;
-		case XK_y: /* paste selection */
-		case XK_Y:
-			XConvertSelection(dpy, (ev->state & ShiftMask) ? clip : XA_PRIMARY,
-			                  utf8, utf8, win, CurrentTime);
-			return;
-		case XK_Left:
-		case XK_KP_Left:
-			movewordedge(-1);
-			goto draw;
-		case XK_Right:
-		case XK_KP_Right:
-			movewordedge(+1);
-			goto draw;
-		case XK_Return:
-		case XK_KP_Enter:
-			break;
-		case XK_bracketleft:
-			cleanup();
-			exit(1);
-		default:
-			return;
-		}
-	} else if (ev->state & Mod1Mask) {
-		switch(ksym) {
-		case XK_b:
-			movewordedge(-1);
-			goto draw;
-		case XK_f:
-			movewordedge(+1);
-			goto draw;
-		case XK_g: ksym = XK_Home;  break;
-		case XK_G: ksym = XK_End;   break;
-		case XK_h: ksym = XK_Up;    break;
-		case XK_j: ksym = XK_Next;  break;
-		case XK_k: ksym = XK_Prior; break;
-		case XK_l: ksym = XK_Down;  break;
-		default:
-			return;
-		}
-	}
-
-	switch(ksym) {
-	default:
+    char buf[64];
+    int len;
+    KeySym ksym = NoSymbol;
+    Status status;
+
+    len = XmbLookupString(xic, ev, buf, sizeof buf, &ksym, &status);
+    switch (status) {
+    default: /* XLookupNone, XBufferOverflow */
+        return;
+    case XLookupChars: /* composed string from input method */
+        goto insert;
+    case XLookupKeySym:
+    case XLookupBoth: /* a KeySym and a string are returned: use keysym */
+        break;
+    }
+
+    if (ev->state & ControlMask) {
+        switch(ksym) {
+        case XK_a: ksym = XK_Down;      break; /* C-a next */
+        case XK_e: ksym = XK_Up;        break; /* C-e prev */
+        case XK_b: ksym = XK_Left;      break;
+        case XK_c: ksym = XK_Escape;    break;
+        case XK_d: ksym = XK_Delete;    break;
+        case XK_f: ksym = XK_Right;     break;
+        case XK_g: ksym = XK_Escape;    break;
+        case XK_h: ksym = XK_BackSpace; break;
+        case XK_i: ksym = XK_Tab;       break;
+        case XK_j: /* fallthrough */
+        case XK_J: /* fallthrough */
+        case XK_m: /* fallthrough */
+        case XK_M: ksym = XK_Return; ev->state &= ~ControlMask; break;
+        case XK_n: ksym = XK_Down;      break;
+        case XK_p: ksym = XK_Up;        break;
+
+        case XK_k: /* delete right */
+            text[cursor] = '\0';
+            match();
+            break;
+        case XK_u: /* delete left */
+            insert(NULL, 0 - cursor);
+            break;
+        case XK_w: /* delete word */
+            while (cursor > 0 && strchr(worddelimiters, text[nextrune(-1)]))
+                insert(NULL, nextrune(-1) - cursor);
+            while (cursor > 0 && !strchr(worddelimiters, text[nextrune(-1)]))
+                insert(NULL, nextrune(-1) - cursor);
+            break;
+        case XK_y: /* paste selection */
+        case XK_Y:
+            XConvertSelection(dpy, (ev->state & ShiftMask) ? clip : XA_PRIMARY,
+                              utf8, utf8, win, CurrentTime);
+            return;
+        case XK_Left:
+        case XK_KP_Left:
+            movewordedge(-1);
+            goto draw;
+        case XK_Right:
+        case XK_KP_Right:
+            movewordedge(+1);
+            goto draw;
+        case XK_Return:
+        case XK_KP_Enter:
+            break;
+        case XK_bracketleft:
+            cleanup();
+            exit(1);
+        default:
+            return;
+        }
+    } else if (ev->state & Mod1Mask) {
+        switch(ksym) {
+        case XK_b:
+            movewordedge(-1);
+            goto draw;
+        case XK_f:
+            movewordedge(+1);
+            goto draw;
+        case XK_g: ksym = XK_Home;  break;
+        case XK_G: ksym = XK_End;   break;
+        case XK_h: ksym = XK_Up;    break;
+        case XK_j: ksym = XK_Next;  break;
+        case XK_k: ksym = XK_Prior; break;
+        case XK_l: ksym = XK_Down;  break;
+        default:
+            return;
+        }
+    }
+
+    switch(ksym) {
+    default:
 insert:
-		if (!iscntrl((unsigned char)*buf))
-			insert(buf, len);
-		break;
-	case XK_Delete:
-	case XK_KP_Delete:
-		if (text[cursor] == '\0')
-			return;
-		cursor = nextrune(+1);
-		/* fallthrough */
-	case XK_BackSpace:
-		if (cursor == 0)
-			return;
-		insert(NULL, nextrune(-1) - cursor);
-		break;
-	case XK_End:
-	case XK_KP_End:
-		if (text[cursor] != '\0') {
-			cursor = strlen(text);
-			break;
-		}
-		if (next) {
-			/* jump to end of list and position items in reverse */
-			curr = matchend;
-			calcoffsets();
-			curr = prev;
-			calcoffsets();
-			while (next && (curr = curr->right))
-				calcoffsets();
-		}
-		sel = matchend;
-		break;
-	case XK_Escape:
-		cleanup();
-		exit(1);
-	case XK_Home:
-	case XK_KP_Home:
-		if (sel == matches) {
-			cursor = 0;
-			break;
-		}
-		sel = curr = matches;
-		calcoffsets();
-		break;
-	case XK_Left:
-	case XK_KP_Left:
-		if (cursor > 0 && (!sel || !sel->left || lines > 0)) {
-			cursor = nextrune(-1);
-			break;
-		}
-		if (lines > 0)
-			return;
-		/* fallthrough */
-	case XK_Up:
-	case XK_KP_Up:
-		if (sel && sel->left && (sel = sel->left)->right == curr) {
-			curr = prev;
-			calcoffsets();
-		}
-		break;
-	case XK_Next:
-	case XK_KP_Next:
-		if (!next)
-			return;
-		sel = curr = next;
-		calcoffsets();
-		break;
-	case XK_Prior:
-	case XK_KP_Prior:
-		if (!prev)
-			return;
-		sel = curr = prev;
-		calcoffsets();
-		break;
-	case XK_Return:
-	case XK_KP_Enter:
-		puts((sel && !(ev->state & ShiftMask)) ? sel->text : text);
-		if (!(ev->state & ControlMask)) {
-			cleanup();
-			exit(0);
-		}
-		if (sel)
-			sel->out = 1;
-		break;
-	case XK_Right:
-	case XK_KP_Right:
-		if (text[cursor] != '\0') {
-			cursor = nextrune(+1);
-			break;
-		}
-		if (lines > 0)
-			return;
-		/* fallthrough */
-	case XK_Down:
-	case XK_KP_Down:
-		if (sel && sel->right && (sel = sel->right) == next) {
-			curr = next;
-			calcoffsets();
-		}
-		break;
-	case XK_Tab:
-		if (!sel)
-			return;
-		cursor = strnlen(sel->text, sizeof text - 1);
-		memcpy(text, sel->text, cursor);
-		text[cursor] = '\0';
-		match();
-		break;
-	}
+        if (!iscntrl((unsigned char)*buf))
+            insert(buf, len);
+        break;
+    case XK_Delete:
+    case XK_KP_Delete:
+        if (text[cursor] == '\0')
+            return;
+        cursor = nextrune(+1);
+        /* fallthrough */
+    case XK_BackSpace:
+        if (cursor == 0)
+            return;
+        insert(NULL, nextrune(-1) - cursor);
+        break;
+    case XK_End:
+    case XK_KP_End:
+        if (text[cursor] != '\0') {
+            cursor = strlen(text);
+            break;
+        }
+        if (next) {
+            /* jump to end of list and position items in reverse */
+            curr = matchend;
+            calcoffsets();
+            curr = prev;
+            calcoffsets();
+            while (next && (curr = curr->right))
+                calcoffsets();
+        }
+        sel = matchend;
+        break;
+    case XK_Escape:
+        cleanup();
+        exit(1);
+    case XK_Home:
+    case XK_KP_Home:
+        if (sel == matches) {
+            cursor = 0;
+            break;
+        }
+        sel = curr = matches;
+        calcoffsets();
+        break;
+    case XK_Left:
+    case XK_KP_Left:
+        if (cursor > 0 && (!sel || !sel->left || lines > 0)) {
+            cursor = nextrune(-1);
+            break;
+        }
+        if (lines > 0)
+            return;
+        /* fallthrough */
+    case XK_Up:
+    case XK_KP_Up:
+        if (sel && sel->left && (sel = sel->left)->right == curr) {
+            curr = prev;
+            calcoffsets();
+        }
+        break;
+    case XK_Next:
+    case XK_KP_Next:
+        if (!next)
+            return;
+        sel = curr = next;
+        calcoffsets();
+        break;
+    case XK_Prior:
+    case XK_KP_Prior:
+        if (!prev)
+            return;
+        sel = curr = prev;
+        calcoffsets();
+        break;
+    case XK_Return:
+    case XK_KP_Enter:
+        puts((sel && !(ev->state & ShiftMask)) ? sel->text : text);
+        if (!(ev->state & ControlMask)) {
+            cleanup();
+            exit(0);
+        }
+        if (sel)
+            sel->out = 1;
+        break;
+    case XK_Right:
+    case XK_KP_Right:
+        if (text[cursor] != '\0') {
+            cursor = nextrune(+1);
+            break;
+        }
+        if (lines > 0)
+            return;
+        /* fallthrough */
+    case XK_Down:
+    case XK_KP_Down:
+        if (sel && sel->right && (sel = sel->right) == next) {
+            curr = next;
+            calcoffsets();
+        }
+        break;
+    case XK_Tab:
+        if (!sel)
+            return;
+        cursor = strnlen(sel->text, sizeof text - 1);
+        memcpy(text, sel->text, cursor);
+        text[cursor] = '\0';
+        match();
+        break;
+    }

 draw:
-	drawmenu();
+    drawmenu();
 }

 static void
 paste(void)
 {
-	char *p, *q;
-	int di;
-	unsigned long dl;
-	Atom da;
-
-	/* we have been given the current selection, now insert it into input */
-	if (XGetWindowProperty(dpy, win, utf8, 0, (sizeof text / 4) + 1, False,
-	                   utf8, &da, &di, &dl, &dl, (unsigned char **)&p)
-	    == Success && p) {
-		insert(p, (q = strchr(p, '\n')) ? q - p : (ssize_t)strlen(p));
-		XFree(p);
-	}
-	drawmenu();
+    char *p, *q;
+    int di;
+    unsigned long dl;
+    Atom da;
+
+    /* we have been given the current selection, now insert it into input */
+    if (XGetWindowProperty(dpy, win, utf8, 0, (sizeof text / 4) + 1, False,
+                       utf8, &da, &di, &dl, &dl, (unsigned char **)&p)
+        == Success && p) {
+        insert(p, (q = strchr(p, '\n')) ? q - p : (ssize_t)strlen(p));
+        XFree(p);
+    }
+    drawmenu();
 }

 static void
 readstdin(void)
 {
-	char *line = NULL;
-	size_t i, itemsiz = 0, linesiz = 0;
-	ssize_t len;
-
-	/* read each line from stdin and add it to the item list */
-	for (i = 0; (len = getline(&line, &linesiz, stdin)) != -1; i++) {
-		if (i + 1 >= itemsiz) {
-			itemsiz += 256;
-			if (!(items = realloc(items, itemsiz * sizeof(*items))))
-				die("cannot realloc %zu bytes:", itemsiz * sizeof(*items));
-		}
-		if (line[len - 1] == '\n')
-			line[len - 1] = '\0';
-		if (!(items[i].text = strdup(line)))
-			die("strdup:");
-
-		items[i].out = 0;
-	}
-	free(line);
-	if (items)
-		items[i].text = NULL;
-	lines = MIN(lines, i);
+    char *line = NULL;
+    size_t i, itemsiz = 0, linesiz = 0;
+    ssize_t len;
+
+    /* read each line from stdin and add it to the item list */
+    for (i = 0; (len = getline(&line, &linesiz, stdin)) != -1; i++) {
+        if (i + 1 >= itemsiz) {
+            itemsiz += 256;
+            if (!(items = realloc(items, itemsiz * sizeof(*items))))
+                die("cannot realloc %zu bytes:", itemsiz * sizeof(*items));
+        }
+        if (line[len - 1] == '\n')
+            line[len - 1] = '\0';
+        if (!(items[i].text = strdup(line)))
+            die("strdup:");
+        items[i].out = 0;
+        items[i].distance = 0.0;
+        items[i].index = (int)i; /* record original order for stable tiebreaks */
+    }
+    free(line);
+    if (items)
+        items[i].text = NULL;
+    lines = MIN(lines, i);
 }

 static void
 run(void)
 {
-	XEvent ev;
-
-	while (!XNextEvent(dpy, &ev)) {
-		if (XFilterEvent(&ev, win))
-			continue;
-		switch(ev.type) {
-		case DestroyNotify:
-			if (ev.xdestroywindow.window != win)
-				break;
-			cleanup();
-			exit(1);
-		case Expose:
-			if (ev.xexpose.count == 0)
-				drw_map(drw, win, 0, 0, mw, mh);
-			break;
-		case FocusIn:
-			/* regrab focus from parent window */
-			if (ev.xfocus.window != win)
-				grabfocus();
-			break;
-		case KeyPress:
-			keypress(&ev.xkey);
-			break;
-		case SelectionNotify:
-			if (ev.xselection.property == utf8)
-				paste();
-			break;
-		case VisibilityNotify:
-			if (ev.xvisibility.state != VisibilityUnobscured)
-				XRaiseWindow(dpy, win);
-			break;
-		}
-	}
+    XEvent ev;
+
+    while (!XNextEvent(dpy, &ev)) {
+        if (XFilterEvent(&ev, win))
+            continue;
+        switch(ev.type) {
+        case DestroyNotify:
+            if (ev.xdestroywindow.window != win)
+                break;
+            cleanup();
+            exit(1);
+        case Expose:
+            if (ev.xexpose.count == 0)
+                drw_map(drw, win, 0, 0, mw, mh);
+            break;
+        case FocusIn:
+            /* regrab focus from parent window */
+            if (ev.xfocus.window != win)
+                grabfocus();
+            break;
+        case KeyPress:
+            keypress(&ev.xkey);
+            break;
+        case SelectionNotify:
+            if (ev.xselection.property == utf8)
+                paste();
+            break;
+        case VisibilityNotify:
+            if (ev.xvisibility.state != VisibilityUnobscured)
+                XRaiseWindow(dpy, win);
+            break;
+        }
+    }
 }

 static void
 setup(void)
 {
-	int x, y, i, j;
-	unsigned int du;
-	XSetWindowAttributes swa;
-	XIM xim;
-	Window w, dw, *dws;
-	XWindowAttributes wa;
-	XClassHint ch = {"dmenu", "dmenu"};
+    int x, y, i, j;
+    unsigned int du;
+    XSetWindowAttributes swa;
+    XIM xim;
+    Window w, dw, *dws;
+    XWindowAttributes wa;
+    XClassHint ch = {"dmenu", "dmenu"};
 #ifdef XINERAMA
-	XineramaScreenInfo *info;
-	Window pw;
-	int a, di, n, area = 0;
+    XineramaScreenInfo *info;
+    Window pw;
+    int a, di, n, area = 0;
 #endif
-	/* init appearance */
-	for (j = 0; j < SchemeLast; j++)
-		scheme[j] = drw_scm_create(drw, colors[j], 2);
+    /* init appearance */
+    for (j = 0; j < SchemeLast; j++)
+        scheme[j] = drw_scm_create(drw, colors[j], 2);

-	clip = XInternAtom(dpy, "CLIPBOARD",   False);
-	utf8 = XInternAtom(dpy, "UTF8_STRING", False);
+    clip = XInternAtom(dpy, "CLIPBOARD",   False);
+    utf8 = XInternAtom(dpy, "UTF8_STRING", False);

-	/* calculate menu geometry */
-	bh = drw->fonts->h + 2;
-	lines = MAX(lines, 0);
-	mh = (lines + 1) * bh;
+    /* calculate menu geometry */
+    bh = drw->fonts->h + 2;
+    lines = MAX(lines, 0);
+    mh = (lines + 1) * bh;
 #ifdef XINERAMA
-	i = 0;
-	if (parentwin == root && (info = XineramaQueryScreens(dpy, &n))) {
-		XGetInputFocus(dpy, &w, &di);
-		if (mon >= 0 && mon < n)
-			i = mon;
-		else if (w != root && w != PointerRoot && w != None) {
-			/* find top-level window containing current input focus */
-			do {
-				if (XQueryTree(dpy, (pw = w), &dw, &w, &dws, &du) && dws)
-					XFree(dws);
-			} while (w != root && w != pw);
-			/* find xinerama screen with which the window intersects most */
-			if (XGetWindowAttributes(dpy, pw, &wa))
-				for (j = 0; j < n; j++)
-					if ((a = INTERSECT(wa.x, wa.y, wa.width, wa.height, info[j])) > area) {
-						area = a;
-						i = j;
-					}
-		}
-		/* no focused window is on screen, so use pointer location instead */
-		if (mon < 0 && !area && XQueryPointer(dpy, root, &dw, &dw, &x, &y, &di, &di, &du))
-			for (i = 0; i < n; i++)
-				if (INTERSECT(x, y, 1, 1, info[i]) != 0)
-					break;
-
-		x = info[i].x_org;
-		y = info[i].y_org + (topbar ? 0 : info[i].height - mh);
-		mw = info[i].width;
-		XFree(info);
-	} else
+    i = 0;
+    if (parentwin == root && (info = XineramaQueryScreens(dpy, &n))) {
+        XGetInputFocus(dpy, &w, &di);
+        if (mon >= 0 && mon < n)
+            i = mon;
+        else if (w != root && w != PointerRoot && w != None) {
+            /* find top-level window containing current input focus */
+            do {
+                if (XQueryTree(dpy, (pw = w), &dw, &w, &dws, &du) && dws)
+                    XFree(dws);
+            } while (w != root && w != pw);
+            /* find xinerama screen with which the window intersects most */
+            if (XGetWindowAttributes(dpy, pw, &wa))
+                for (j = 0; j < n; j++)
+                    if ((a = INTERSECT(wa.x, wa.y, wa.width, wa.height, info[j])) > area) {
+                        area = a;
+                        i = j;
+                    }
+        }
+        /* no focused window is on screen, so use pointer location instead */
+        if (mon < 0 && !area && XQueryPointer(dpy, root, &dw, &dw, &x, &y, &di, &di, &du))
+            for (i = 0; i < n; i++)
+                if (INTERSECT(x, y, 1, 1, info[i]) != 0)
+                    break;
+
+        x = info[i].x_org;
+        y = info[i].y_org + (topbar ? 0 : info[i].height - mh);
+        mw = info[i].width;
+        XFree(info);
+    } else
 #endif
-	{
-		if (!XGetWindowAttributes(dpy, parentwin, &wa))
-			die("could not get embedding window attributes: 0x%lx",
-			    parentwin);
-		x = 0;
-		y = topbar ? 0 : wa.height - mh;
-		mw = wa.width;
-	}
-	promptw = (prompt && *prompt) ? TEXTW(prompt) - lrpad / 4 : 0;
-	inputw = mw / 3; /* input width: ~33% of monitor width */
-	match();
-
-	/* create menu window */
-	swa.override_redirect = True;
-	swa.background_pixel = scheme[SchemeNorm][ColBg].pixel;
-	swa.event_mask = ExposureMask | KeyPressMask | VisibilityChangeMask;
-	win = XCreateWindow(dpy, root, x, y, mw, mh, 0,
-	                    CopyFromParent, CopyFromParent, CopyFromParent,
-	                    CWOverrideRedirect | CWBackPixel | CWEventMask, &swa);
-	XSetClassHint(dpy, win, &ch);
-
-	/* input methods */
-	if ((xim = XOpenIM(dpy, NULL, NULL, NULL)) == NULL)
-		die("XOpenIM failed: could not open input device");
-
-	xic = XCreateIC(xim, XNInputStyle, XIMPreeditNothing | XIMStatusNothing,
-	                XNClientWindow, win, XNFocusWindow, win, NULL);
-
-	XMapRaised(dpy, win);
-	if (embed) {
-		XReparentWindow(dpy, win, parentwin, x, y);
-		XSelectInput(dpy, parentwin, FocusChangeMask | SubstructureNotifyMask);
-		if (XQueryTree(dpy, parentwin, &dw, &w, &dws, &du) && dws) {
-			for (i = 0; i < du && dws[i] != win; ++i)
-				XSelectInput(dpy, dws[i], FocusChangeMask);
-			XFree(dws);
-		}
-		grabfocus();
-	}
-	drw_resize(drw, mw, mh);
-	drawmenu();
+    {
+        if (!XGetWindowAttributes(dpy, parentwin, &wa))
+            die("could not get embedding window attributes: 0x%lx",
+                parentwin);
+        x = 0;
+        y = topbar ? 0 : wa.height - mh;
+        mw = wa.width;
+    }
+    promptw = (prompt && *prompt) ? TEXTW(prompt) - lrpad / 4 : 0;
+    inputw = mw / 3; /* input width: ~33% of monitor width */
+    match();
+
+    /* create menu window */
+    swa.override_redirect = True;
+    swa.background_pixel = scheme[SchemeNorm][ColBg].pixel;
+    swa.event_mask = ExposureMask | KeyPressMask | VisibilityChangeMask;
+    win = XCreateWindow(dpy, root, x, y, mw, mh, 0,
+                        CopyFromParent, CopyFromParent, CopyFromParent,
+                        CWOverrideRedirect | CWBackPixel | CWEventMask, &swa);
+    XSetClassHint(dpy, win, &ch);
+
+    /* input methods */
+    XSetLocaleModifiers("");
+    if ((xim = XOpenIM(dpy, NULL, NULL, NULL)) == NULL)
+        die("XOpenIM failed: could not open input device");
+
+    xic = XCreateIC(xim, XNInputStyle, XIMPreeditNothing | XIMStatusNothing,
+                    XNClientWindow, win, XNFocusWindow, win, NULL);
+
+    XMapRaised(dpy, win);
+    if (embed) {
+        XReparentWindow(dpy, win, parentwin, x, y);
+        XSelectInput(dpy, parentwin, FocusChangeMask | SubstructureNotifyMask);
+        if (XQueryTree(dpy, parentwin, &dw, &w, &dws, &du) && dws) {
+            for (i = 0; i < du && dws[i] != win; ++i)
+                XSelectInput(dpy, dws[i], FocusChangeMask);
+            XFree(dws);
+        }
+        grabfocus();
+    }
+    drw_resize(drw, mw, mh);
+    drawmenu();
 }

 static void
 usage(void)
 {
-	die("usage: dmenu [-bfiv] [-l lines] [-p prompt] [-fn font] [-m monitor]\n"
-	    "             [-nb color] [-nf color] [-sb color] [-sf color] [-w windowid]");
+    die("usage: dmenu [-bFfiv] [-l lines] [-p prompt] [-fn font] [-m monitor]\n"
+        "             [-nb color] [-nf color] [-sb color] [-sf color] [-w windowid]");
 }

 int
 main(int argc, char *argv[])
 {
-	XWindowAttributes wa;
-	int i, fast = 0;
-
-	for (i = 1; i < argc; i++)
-		/* these options take no arguments */
-		if (!strcmp(argv[i], "-v")) {      /* prints version information */
-			puts("dmenu-"VERSION);
-			exit(0);
-		} else if (!strcmp(argv[i], "-b")) /* appears at the bottom of the screen */
-			topbar = 0;
-		else if (!strcmp(argv[i], "-f"))   /* grabs keyboard before reading stdin */
-			fast = 1;
-		else if (!strcmp(argv[i], "-i")) { /* case-insensitive item matching */
-			fstrncmp = strncasecmp;
-			fstrstr = cistrstr;
-		} else if (i + 1 == argc)
-			usage();
-		/* these options take one argument */
-		else if (!strcmp(argv[i], "-l"))   /* number of lines in vertical list */
-			lines = atoi(argv[++i]);
-		else if (!strcmp(argv[i], "-m"))
-			mon = atoi(argv[++i]);
-		else if (!strcmp(argv[i], "-p"))   /* adds prompt to left of input field */
-			prompt = argv[++i];
-		else if (!strcmp(argv[i], "-fn"))  /* font or font set */
-			fonts[0] = argv[++i];
-		else if (!strcmp(argv[i], "-nb"))  /* normal background color */
-			colors[SchemeNorm][ColBg] = argv[++i];
-		else if (!strcmp(argv[i], "-nf"))  /* normal foreground color */
-			colors[SchemeNorm][ColFg] = argv[++i];
-		else if (!strcmp(argv[i], "-sb"))  /* selected background color */
-			colors[SchemeSel][ColBg] = argv[++i];
-		else if (!strcmp(argv[i], "-sf"))  /* selected foreground color */
-			colors[SchemeSel][ColFg] = argv[++i];
-		else if (!strcmp(argv[i], "-w"))   /* embedding window id */
-			embed = argv[++i];
-		else
-			usage();
-
-	if (!setlocale(LC_CTYPE, "") || !XSupportsLocale())
-		fputs("warning: no locale support\n", stderr);
-	if (!(dpy = XOpenDisplay(NULL)))
-		die("cannot open display");
-	screen = DefaultScreen(dpy);
-	root = RootWindow(dpy, screen);
-	if (!embed || !(parentwin = strtol(embed, NULL, 0)))
-		parentwin = root;
-	if (!XGetWindowAttributes(dpy, parentwin, &wa))
-		die("could not get embedding window attributes: 0x%lx",
-		    parentwin);
-	drw = drw_create(dpy, screen, root, wa.width, wa.height);
-	if (!drw_fontset_create(drw, fonts, LENGTH(fonts)))
-		die("no fonts could be loaded.");
-	lrpad = drw->fonts->h;
+    XWindowAttributes wa;
+    int i, fast = 0;
+
+    for (i = 1; i < argc; i++)
+        /* these options take no arguments */
+        if (!strcmp(argv[i], "-v")) {      /* prints version information */
+            puts("dmenu-"VERSION);
+            exit(0);
+        } else if (!strcmp(argv[i], "-b")) /* appears at the bottom of the screen */
+            topbar = 0;
+        else if (!strcmp(argv[i], "-F"))   /* disables fuzzy matching */
+            fuzzy = 0;
+        else if (!strcmp(argv[i], "-f"))   /* grabs keyboard before reading stdin */
+            fast = 1;
+        else if (!strcmp(argv[i], "-s")) { /* case-sensitive item matching for literal mode */
+            fstrncmp = strncmp;
+            fstrstr = strstr;
+        } else if (i + 1 == argc)
+            usage();
+            /* these options take one argument */
+        else if (!strcmp(argv[i], "-l"))   /* number of lines in vertical list */
+            lines = atoi(argv[++i]);
+        else if (!strcmp(argv[i], "-m"))
+            mon = atoi(argv[++i]);
+        else if (!strcmp(argv[i], "-p"))   /* adds prompt to left of input field */
+            prompt = argv[++i];
+        else if (!strcmp(argv[i], "-fn"))  /* font or font set */
+            fonts[0] = argv[++i];
+        else if (!strcmp(argv[i], "-nb"))  /* normal background color */
+            colors[SchemeNorm][ColBg] = argv[++i];
+        else if (!strcmp(argv[i], "-nf"))  /* normal foreground color */
+            colors[SchemeNorm][ColFg] = argv[++i];
+        else if (!strcmp(argv[i], "-sb"))  /* selected background color */
+            colors[SchemeSel][ColBg] = argv[++i];
+        else if (!strcmp(argv[i], "-sf"))  /* selected foreground color */
+            colors[SchemeSel][ColFg] = argv[++i];
+        else if (!strcmp(argv[i], "-w"))   /* embedding window id */
+            embed = argv[++i];
+        else
+            usage();
+
+    if (!setlocale(LC_CTYPE, "") || !XSupportsLocale())
+        fputs("warning: no locale support\n", stderr);
+    if (!(dpy = XOpenDisplay(NULL)))
+        die("cannot open display");
+    screen = DefaultScreen(dpy);
+    root = RootWindow(dpy, screen);
+    if (!embed || !(parentwin = strtol(embed, NULL, 0)))
+        parentwin = root;
+    if (!XGetWindowAttributes(dpy, parentwin, &wa))
+        die("could not get embedding window attributes: 0x%lx",
+            parentwin);
+    drw = drw_create(dpy, screen, root, wa.width, wa.height);
+    if (!drw_fontset_create(drw, fonts, LENGTH(fonts)))
+        die("no fonts could be loaded.");
+    lrpad = drw->fonts->h;

 #ifdef __OpenBSD__
-	if (pledge("stdio rpath", NULL) == -1)
-		die("pledge");
+    if (pledge("stdio rpath", NULL) == -1)
+        die("pledge");
 #endif

-	if (fast && !isatty(0)) {
-		grabkeyboard();
-		readstdin();
-	} else {
-		readstdin();
-		grabkeyboard();
-	}
-	setup();
-	run();
-
-	return 1; /* unreachable */
+    if (fast && !isatty(0)) {
+        grabkeyboard();
+        readstdin();
+    } else {
+        readstdin();
+        grabkeyboard();
+    }
+    setup();
+    run();
+
+    return 1; /* unreachable */
 }
--
2.51.2
